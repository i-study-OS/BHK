> OS를 사용자 관점이 아닌, OS 개발자 관점에서 운영체제라고 생각하기
>
> 인간의 신체가 뇌의 통제를 받듯, 컴퓨터 하드웨어는 운영체제의 통제를 받고 있고, 그 운영체제는 사람이 프로그래밍 하는 것
>
> 나를 windows XP나 Linux같은 운영체제라고 생각하고 내가 할 일이 무엇인지를 생각해보면 된다.



####  Chapter 1. 운영체제란 무엇인가 ?

#### **OS**

- 컴퓨터의 하드웨어 바로 위에 설치되는 것

- 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는(다리역할) 소프트웨어 계층
- 여러 시스템의 자원들을 효율적으로 관리하고, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있는 환경을 제공하는 **여러 프로그램들의 모임**

하드웨어 위에 운영체제를 설치해놓으면 두개가 한몸이 되어 서로에게 접근이 되면서 사용자가 운영체제의 관리를 받으며 실행되도록 한다.



#### [커널 (좁은 의미의 운영체제)](https://goodmilktea.tistory.com/23) 

- 컴퓨터에 전원을 켜면 운영체제는 이와 동시에 수행이 되는데, 소프트웨어가 컴퓨터 시스템에서 수행되기 위해서는 메모리에 그 프로그램이 올라가 있어야 한다. 
- 운영체제도 소프트웨어이기 떄문에 전원이 켜짐과 동시에 메모리에 올라가야 한다. 운영체제는 <u>한정된 메모리 공간이기 때문에 낭비를 하지 않기 위해 필요한 부분만을 전원이 켜짐과 동시에 올려놓고, 그렇지 않은 부분은 필요 시에 메모리에 올려서 사용하게 된다.</u>
- <u>메모리에 상주하고 있는 운영체제의 부분, *좁고 핵심적인 운영체제* 를 커널</u>이라고 한다.



#### [넓은 운영체제](https://chozzza-diary.tistory.com/50)

- 커널을 포함하여 여러 주변 시스템을 다루는 유틸리티를 포함하여 운영체제라고 부른다. 독립적이지만 운영체제의 범주에는 포함시킴 
- 윈도우의 운영체제를 컴퓨터에 설치하게 되면 단순히 커널만 있는것이 아니라 여러가지 부수적 프로그램이 설치되는데, 그런 프로그램들은 별도의 소프트웨어이기 때문에 항상 메모리에 상주하는 커널에 포함되지는 않는다. 
- 적어도 컴퓨터 하드웨어 위에 운영체제를 설치하게 되면 커널 뿐만 아니라 최소한의 필요로 되어지는 유틸리티를 포함하여 설치되기 때문에 이들을 포함하여 넓은 의미로 운영체제의 범주에 포함시킨다. 
- 보통 전공자 입장에서는 커널만을 이야기한다.



#### **운영체제의 목적, 목표**

1. **컴퓨터 시스템의 자원을 효율적으로 관리해주는 것 (자원관리자)** <- <u>주어진 하드웨어를 가지고 최대한의 성능을 내려고 하는 것</u>
2. 리소스들(cpu, 기억장치, 입출력장치 등)을 효율적으로 관리하는 것(효율성, 형평성)
   - 운영체제는 하드웨어 자원뿐만 아니라 소프트웨어 자원 또한 관리함
   - 사용자 및 운영체제 자신을 보호하기도 함
3. 하드웨어와 어떻게 인터페이스를 하는가 ?
4. 각종 소프트웨어와 어떻게 인터랙션을 하는가 ?

   - 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
   - 컴터 안에서 가장 빠른 자원인 cpu가 하나일 때 프로그램들은 한개의 cpu를 공유함. 이때 공유 속도는 혼자 쓰는걸로 착각할 정도로 빠르다.

운영체제에서의 자원이란 ? : 컴퓨터 시스템의 cpu, 메모리, 입출력장치, 기억장치 등 ..

요즘 많이 보이는 멀티코어,멀티프로세서란 ?  ➡️  **cpu**가 여러개인 것

<u>어떤 프로그램에게 메모리를 어떻게 할당해야할지</u>도 운영체제의 역할이다(효율성, 형평성)

- 한정된 메모리에 프로그램들을 어떻게 올려야 할지 

- 특정 프로그램이 지나치게 대우를 못받는 것을 방지하는 것

  여러 프로그램이 동시에 실행되려면 각각의 메모리들이 각 프로그램에 동시에 올려져 있을 텐데, 실행중인 프로그램들에 메모리 공간을 적절하게 분배해주는 것.

- 한정된 cpu나 메모리를 가지고 어떻게 좋은 성능을 뽑아낼 수 있는지 



#### 운영체제의 분류

1. ###### 동시 작업 가능 여부

   - 단일 작업(Single-tasking): 한번에 하나만 처리해주는 것들(MS-DOS), 한 프로그램 돌려놓으면 입력도 할 수 없음. 설계하기는 쉬움.
   - 다중 작업(Multi-tasking): 현대적인 운영체제들(UNIX, MS Windows)와 같은 것들은 동시에 실행되는 작업들을 처리해줌.
     - 특수 목적을 위한 것들(엘레베이터, 전화만 되는 휴대폰)은 아직도 단일 작업을 하지만 스마트폰 같은 것들은 다중 작업을 지원한다.



2. ###### 사용자의 수

   - 단일 사용자: MS-DOS, MS-Windows(예전엔 단일이었음. 요즘은 계정 여러개 만들 수도 있고, 원격에서 서버 기능 추가하면 Windows에도 여러명 사용이 가능하긴 함)

   - 다중 사용자: **여러개의 계정, 동시접속**, UNIX, NT Server(보안 기능 추가, 형평성 있게 자원을 관리해주는 것들도 추가)

     

3. ###### 처리 방식

   - 시분할 방식(time sharing): 여러 작업을 수행할 떄, 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용. 일괄 처리 시스템에 비해 짧응 응답 시간을 가진다. interactive한 프로그램이 가능하다. 짧은 응답시간을 가진다. 사용자가 느끼기에 빠르게 보이면서 주어진 자원을 최대한 활용하도록 하는 것(사람에 특화된 시스템)

     ex. iOS, AOS, Windows 등

   - 실시간 방식(Realtime OS): 시분할과 실시간 둘다 빨라 보이지만, 실제 개념적으로는 다르다. 실시간 시스템은 데드라인이 있어서 정해진 시간 안에 반드시 결과가 나오는 것을 보장한다. 시분할 방식은 일반적인 범용 컴퓨터에서 사용되며, 실시간 방식은 특수한 목적을 가진 시스템(원자로/공장제어, 미사일 제어, 반도체장비, 로보트제어 등)에서 그 작업이 반드시 정해진 시간안에 처리되도록 하는 방식.
     - 실시간 시스템의 개념 확장:
       - Soft realtime system(연성 실시간 시스템): 데드라인은 있지만 큰 문제가 없는 것들. 영화는 초당 24프레임을 맞추지 못하면 끊기게 된지만 큰 치명적 결과가 초래되지는 않지만 데드라인은 존재하는 경우
       - Hard realtime system(경성 실시간 시스템): 로봇, 반도체, 원자로와 같은 경우.
   - 일괄처리 방식(Batch Processing): 작업 요청의 일정량을 모아서 한꺼번에 처리해주는 것, 바로바로가 아닌 한꺼번에 처리이기 때문에 작업이 완전 종료될 때까지 기다려야 한다. 현대에는 찾아보기 어렵다. Ex. OMR 카드리딩 



#### 우리가 사용하고 있는 운영체제

: 다중 작업을 지원하고, 다중사용자를 지원하며, 시분할 방식으로 운영되고 있다.



#### 필요한 용어 정리

- Multitasking: cpu에서는 매 순간 하나의 작업만 수행하고 있지만, 마치 동시에 수행되는 것처럼 보인다. 컴퓨터 저반에서 여러 일을 빠르게 번갈아가며 사용하고 있는 것이다.  하나의 프로그램이 끝나기 전에 다른 프로그램도 실행가능한 것을 말함

- MultiProgramming: Multitasking과 같지만, <u>메모리 측면을 강조한 용어</u>. 여러 프로그램이 메모리에 올라가있음을 강조하는 것이다. 

- Time sharing: Multitasking과 같지만, 시간을 공유하는(시분할) 측면에서 CPU를 더 강조한 용어이다. cpu를 시간별로 쪼개어 진행되는 것. 

  Multitasking, MultiProgramming, Time sharing 의 차이: Multitasking이 되려면 메모리에 여러 프로그램이 올라가 있어야 한다. 뭘 중점으로 뒀는지에 따라 용어만 다르지 사실 같은 맥락임.

- MultiProcess: 실행중인 프로그램, 여러 프로그램이 동시에 실행된다.
- MultiProcessor:  다중처리기. Processor는 보통 cpu(처리기)를 말한다. 즉 cpu가 여러개 있는 컴퓨터를 멀티 프로세서라고 한다. 일반적인 컴퓨터는 CPU가 1개 존재하지만 여러 프로그램이 cpu에 동시에 들어갈 수 있는데, 하드웨어적으로 다르다. cpu가 여러개 있는 구조.
  - 우리는 보통 cpu가 1개 달린 범용적인 운영체제에 대하여 배우지만, cpu가 여러개 달린 시스템도 있다. 그런 경우는 어떻게 병렬적으로 운영되는지에 대해 알아볼 수 있다.



##### 유닉스 운영체제(UNIX)

: 멀티 태스킹이 가능. 그러나 어셈블리어(기계어에 가까운 언어)로 만들어서 초기 코드가 복잡했다. 너무 복잡한 이유로 프로그래밍 언어를 새로 만들게 됨(C언어)

C언어는 사람이 이해하기 편리한 측면도 있지만, 기계어랑도 가까운 언어이다. 1:1 매핑은 안되지만 하드웨어를 직접적으로 다루는데에 기존의 고급언어들과는 달리 기계어랑도 가까우면서 사람이라도 가깝다.

유닉스 운영체제는 거의 대부분이 C언어로 작성되어 있다.

높은 이식성. 하나의 컴퓨터에서 돌아가는 유닉스를 기계어 집합이 다른 컴퓨터에 이식하는 것이 가능하다. 기계어 집합이 다르다면 새로운 운영체제를 만들어야 하지만 C언어로 작성되어있기 때문에 하나의 컴퓨터에서 돌아가는 유닉스를 다른 컴퓨터에서 돌리려면 C언어로 작성되어있기 때문에 컴파일만 시키면 된다. 즉 핵심적인 부분들만 커널에 집어넣는 구조. 

소스코드가 공개되어 있어 학술적으로 사용하기 좋다.

커널의 크기를 최소한으로 만들어 메모리를 최대한 적게 사용



###### DOS:

 단일 사용자, 단일 작업만 해주는 OS



#### 운영체제의 구조

###### CPU 스케줄링: 

- 누구에게 CPU를 줄 것인지

- 먼저 온 것을 처리해주는 선착순 처리(은행 업무, 화장실)
- CPU를 짧게 쓰려고 하는 사람에게 먼저 주게 되면 평균적으로 모두의 업무가 줄어듦
- CPU를 줬다 뺐다 짧은 시간씩 돌리는 것이 더 효율적일 것이라고 생각하여 빠른 CPU스케줄링으로 점점 발전해 나감.



###### 메모리 관리:

- 한정된 메모리 자원에 비하여 여러 프로그램들이 동시에 올라가고 싶어한다.

- 어떤 프로그램에게 얼마정도의 메모리를 할당해야 하는가
- 공평하게 1/n 씩 할당해주고 싶어도, 메모리를 많이 필요로 하는 프로그램도 있기 때문
- 메모리 분배 이슈는 프로그램들이 점점 많아지면 각각 갖는 메모리 공간들이 작기 때문에 최소한의 실행에 필요한 부분은 메모리에 올라와있어야 하지만, 프로그램이 너무 많아서 메모리를 할당 할 수 없다면 전체 시스템이 원활하게 실행되지 못한다 -> 적어도 cpu에서 원활하게 실행되기 위해서 최소한의 필요한 용량(메모리)는 받을 수 있도록 지원해주자는 것(working set 모델이라고 한다)
  + Working Set : 실행중인 프로세스가 자주 참조하는 페이지들의 집합. 스레싱을 예방하기 위해 존재한다. 메모리의 크기는 한정되어있기 때문에 디스크가 꽉차게 된다면 누군가는 쫓겨나야 한다. 미래에 사용할 것이 무엇인지를 알 수 없기 때문에, 메모리에 올라간 어떠한 데이터가 가까운 미래에 다시 사용될 가능성이 높은지 낮은지에 대해 예측하는 것이 과거 이력을 통하여 미래를 예측한다.
  + Thrashing: 다중 프로그래밍 정도가 높아지며(동시 실행 프로세스 수 증가) 메모리에 페이지 폴트가 많이 일어나 프로그램 수행보다 페이지 교환이 더 많이 일어나는 현상이다. 성능의 저하를 초래하는 악순환이다.
  + Page Fault: 페이지 부재. 메모리에 적재된 페이지 중 사용 페이지가 없을 때를 가리킨다. 대체적으로 빈 페이지가 하나도 없거나, 미리 정한 수보다 적을 때 발생한다.



###### 파일 관리:

- 디스크에 들어온 요청들을 먼저 들어온 순서대로 처리할 수도 있지만, Head에 가까운 위치에 있다면 먼저 처리해 주는 등 디스크도 헤드가 이동하면서 중간에 요청이 들어오면 처리하면서 진행한다던지 특성에 맞게 관리하여야 한다.
- 파일관리, 디스크는 헤드 자체가 움직이면서 처리하기 때문에 어떻게 하면 움직임을 최소화하며 많은 일을 처리할 수 있는지
- ex. 1층에 있는 사용자들이 100, 2, 99, 8 순으로 버튼 눌렀을 때 2, 8, 99, 100 순으로 갈 수 있는지



###### I/O 관리:

- 기본적으로 I/O 장치가 다른 장치들보다 상대적으로 느리다. 이런 상황에서 I/O Device가 cpu와 어떻게 정보를 주고 받을지에 대한 관리

- interrupt에 기반하여 관리되어지고 있다. cpu는 워낙 빠르기 떄문에  I/O가 무엇을 하는지에 대해 알고 있지 않으며 항상 본인이 할 일을 하고 있다. 그렇기에 I/O가 보고할 일이 있으면 interrupt를 걸어서 cpu가 그때서야 파악하고 처리해주는 중간에 방해받지 않으며 일처리를 해주는 방식으로 관리되어진다.



###### 프로세스 관리:

프로세스의 생성과 삭제, 자원 할당 및 반환, 프로세스 간의 협력이 어떻게 이루어져야 하는지에 대한 관리



