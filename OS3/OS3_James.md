# 프로세스 관리

## 1. 프로세스의 개념

#### 프로세스의 개념

![Screen Shot 2021-03-28 at 9 03 38 PM](https://user-images.githubusercontent.com/69072471/112751486-457f2d00-9009-11eb-98aa-f438be8fdb37.png)

**<<실행 중인 프로그램[Program in execution]을 뜻한다>>**

- 디스크에 존재하는 프로그램은 실행 파일로써 존재하고 메모리에 올라가서는 실행이 되고 생명력을 갖는 **프로세스**가 된다.
- 프로세스는 CPU를 획득하여 자신의 코드를 실행한다.



**프로세스의 문맥[Context]**

- 프로세스가 현재 어떤 상태에서 어떻게 수행되고 있는지 규명하기 위해 필요한 **정보**를 의미한다.

🙋 프로세스의 문맥은 무엇을 위해 존재하는가?

📚 하루종일 컴퓨터게임을 하면 좋겠지만 우리는 게임을 진행하다 종료해야 할 상황이 자주 생긴다. 이 경우 게임을 끄기전에 게임시점을 저장한다. 이미 깬 부분을 다시 해야 하는 것 만큼 끔찍한일이 없기 때문이다. 게임을 저장하려면 컴퓨터는 게임을 어디까지 진행했는지에 알아야 저장을 할 수가 있다. 

이와 비슷하게 시분할 환경에서 프로세스는 CPU를 넘겨준 뒤 추후에 다시 획득하는 식으로 CPU 관리가 이뤄진다. 이 과정에서 수행하던 명령을 잠시 중단하게 되는데 나중에 CPU를 획득한 뒤 명령을 재개하려면 직전 명령의 직전 수행시점이 어떤상태인지 알 필요가 있다. 명령이 어느지점까지 진행되었는지에 대한 정보가 있어야 명령 재개를 할 수가 있기 때문이고 그렇기 때문에 프로세스의 문맥이 필요하다.



프로세스의 문맥은 크게 3가지로 분류된다.

- 하드웨어 문맥
  - Program Counter 값, 
  - 레지스터에 저장된 값

- 프로세스의 주소공간
  - Code
  - Data
  - Stack

- 커널상의 문맥
  - PCB
  - Kernel Stack



## 2. 프로세스의 상태

![Screen Shot 2021-03-28 at 9 57 20 PM](https://user-images.githubusercontent.com/69072471/112752962-947c9080-9010-11eb-9aee-67428da41786.png)

#### 실행 상태[Running]

- 프로세스가 CPU를 보유하는 상태
- 프로세스가 기계어 명령을 실행하는 상태

![Screen Shot 2021-03-28 at 9 58 29 PM](https://user-images.githubusercontent.com/69072471/112752988-c261d500-9010-11eb-89a8-479697cb29ac.png)

#### 준비 상태[Ready]

- 명령어를 실행할 준비는 되었으나 CPU를 할당받지 못한 상태

#### 봉쇄[Blocked, Wait, Sleep]

- CPU를 할당받았으나 명령을 실행할 수 없는 상태



#### 그외

**시작[New] 싱태:**

- 프로세스를 위한 자료구조는 생성되었으나 메모리 획득을 승인받지 못한 상태



**완료[Terminated] 상태:**

- 프로세스가 종료되었으나 운영체제가 관련된 자료구조를 정리하지 못한 상태



#### 프로세스 상태 변화 

1. *프로세스 A을 [실행] 하다 interrupt가 발생하면 CPU의 제어권은 `프로그램 → 운영체제` 로 넘어가게 된다.*

2. *운영체제는 수행중이던 프로세스의 문맥을 저장하고 [준비상태]에 있는 다른 프로세스 중 하나에게 CPU제어권을 부여한다. (타이머 인터럽트 처리루틴 적용)*
3. *프로세스 A의 상태는 `[실행] → [준비]` 상태로 변한다.*
4. 선택받은 프로세스 B의 상태는 `[준비] → [실행]` 상태로 변한다.*

*이와 같이 실행시킬 프로세스를 변경하기 위해 수행중인 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정을 **문맥교환[ context switch]**라 부른다

*이 과정 중 새로운 프로세스가 CPU의 제어권을 할당 받는 과정을 **CPU 디스패치[dispatch]**라 부른다.



#### 입출력 프로세스 상태 변화: 

#### 프로세스A의 요청에 의해 디스크에서 파일 내용을 읽어와야 하는 경우

- 디스크에서 읽는 작업은 CPU 처리속도보다 긴 시간이 소요된다.

- 이 시간동안 CPU가 프로세스에게 할당되어있으면 비효율적으로 낭비된다.

따라서

1. 입출력이 완료될 때까지  프로세스 A는 CPU를 운영체제에게 반환한다 & 프로세스 `[실행] → [봉쇄]`
2. CPU 스케쥴러는 다른 적절한 프로세스에게 CPU를 할당한다.
3. 입출력 대기줄[Queue]에 기다리던 프로세스A는 서비스를 받는다
4. Disk controller로부터 발생된 interrupt를 통해 CPU는 프로세스A가 서비스를 받았다는 것을 알게된다.
5. CPU를 사용하던 다른 프로세스의 상태가 `[사용자 모드 실행상태] → [커널모드 실행상태]` 로 변화게 되고
6. 프로세스 A의 상태는 `[봉쇄] → [준비]`로 변하게 된 후
7. 디스크 로컬 buffer에 있는 자료를 메모리로 이동시키는 일련의 업무를 수행한다.
8. 프로세스 A에게 다시 CPU가 할당되고 수행시점 이후의 코드가 실행 된다.



## 3. PCB[Process Control Block]

![Screen Shot 2021-03-28 at 10 28 07 PM](https://user-images.githubusercontent.com/69072471/112753963-e1fafc80-9014-11eb-89e6-6d72d8d8c0b2.png)

#### PCB의 요소

- 프로세스의 상태 [Process state]
  - Process에  CPU를 할당해도 되는지 확인한다.
- 프로그램 카운터의 값
  - 다음에 수행할 명령어의 위치를 나타낸다.
- CPU 레지스터의 값
  - CPU 연산을 위해 현 시점에 어떤 값을 레지스터에 저장했는지 나타낸다.
- CPU 스케줄링 정보
  - 각각의 프로세스에 스케줄링을 위해 필요한 정보이다.
- 메모리 관리 정보
  - 각각의 프로세스에 메모리 할당을 위해 필요한 정보이다.
- 자원 사용 정보
  - 자원 사용 요금을 계산해 청구하는 용도로 사용된다.
- 입출력 상태 정보
  - 프로세스의 입출력 관련 상태 정보를 나타낸다.



## 4. 문맥 교환[Context Switch]

![Screen Shot 2021-03-28 at 10 35 26 PM](https://user-images.githubusercontent.com/69072471/112754179-e7a51200-9015-11eb-9abd-07aa89a82acf.png)



***하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻한다.***



- 문맥 교환 중 원래 CPU를 보유하고 있던 프로세스는 프로그램 카운터 값 등 프로세스의 문맥을 자신의 PCB에 저장한다.

- 새롭게 할당된 프로세스는 예쩐에 저장했던 자신의 문맥을 PCB로 부터 실제 하드웨어로 **복원**시키는 과정을 거친다.



🙋 문맥 교환은 어떠한 경우에 발생하나요?

📚 Timer interrupt가 발생한 경우에도 발생하고 프로세스가 입출력 요청이나 다른 조건을 충족하지 못해 **CPU를 회수**당하고 **봉쇄상태**가 되는 경우에도 발생합니다.

![Screen Shot 2021-03-28 at 10 43 20 PM](https://user-images.githubusercontent.com/69072471/112754429-03f57e80-9017-11eb-974f-e233d50c4c33.png)

*프로세스가 실행상태일 때 system call이나 interrupt가 발생하면 CPU의 제어권이 운영체제로 넘어와 실행 중이던 프로세스의 업무를 잠시 멈추고 운영체제 커널코드가 실행되는데..*

이 과정을 문맥교환이라고 하지 않는다!

*왜냐하면 단지 프로세스의 실행모드를 사용자모드에서 커널모드로 바꾸는 것이지*

**CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 때문이다!**

문맥교환에는 더 많은 **오버헤드**가 뒤따른다.



## 5. 프로세스를 스케줄링하기 위한 큐

**프로세스의 상태 관리는 커널의 주소영역 중 데이터 영역에 다양한 queue를 두어 수행한다.**

**물론 이 모든 관리는 커널이 총체적으로 관리한다**

![Screen Shot 2021-03-28 at 11 35 09 PM](https://user-images.githubusercontent.com/69072471/112756047-47072000-901e-11eb-96ae-d45e4a3deddb.png)



#### 하드웨어 자원을 기다리는 프로세스의 줄 루틴: 입출력 장치 수행 요청

1. 프로세스 → 디스크 입출력 큐[Device Queue] 줄에 순서대로 대기
2. 디스크 컨트롤러 입출력 작업 순서대로 수행
3. 작업 완료시 디스크 컨트롤러 → CPU에 인터럽트 발생
4. 인터럽트 처리루틴에 따라 프로세스 → CPU 기다리는 큐로 이동 및 대기



#### 소프트웨어 자원을 기다리는 프로세스의 줄 루틴: 공유데이터 접근

공유 데이터는 한 번에 한 프로세스만 접근 가능해야 한다.

따라서 여러 프로세스가 공유데이터에 접근하려 하는 경우:

1. 공유데이터를 기다리는 줄에 순서대로 줄을 서게 하고
2. 프로세스가 데이터를 반납한 뒤에 순서대로 다른 프로세스에게 접근권한을 부여한다.



## 6. 스케줄러

어떤 프로세스에게 자원을 할당할지 결정하는 **운영체제 커널의 코드**를 지칭한다.

![Screen Shot 2021-03-28 at 11 46 47 PM](https://user-images.githubusercontent.com/69072471/112756382-dfea6b00-901f-11eb-9080-59f1727934d3.png)



- **ready queue**는 CPU만 얻으면 당장 실행할 수 있는 process의 집합이고 CPU에서 실행되기 위해서는 프로세스가 메모리를 보유해야 하므로, **장기 스케줄러**는 프로세스에게 메모리를 할당하는 문제에 관여한다. 
- 시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출되어서 준비상태의 프로세스 중에서 어떤 프로세스를 다음번에 실행상태로 만들 것인지 결정한다.

#현대의 시분할 시스템용 운영체제에서는 프로세스가 시작상태가 되면 장기 스케줄러 없이 바로 해당 프로세스에 메모리를 할당해 ready queue에 넣어주게 된다.

- 중기 스케줄러가 장기 스케줄러를 대체하는 경우가 많다.

`swap out`

- 너무 많은 프로세스가 메모리에 적제되어 각 프로세스당 보유하고 있는 메모리양이 극도로 적어지면 시스템의 성능이 심각하게 저하될 수 있다.이런 경우 여유 공간 마련을 위해 프로세스 중 일부로부터 메모리를 통째로 빼앗아 디스크의 스왑 영역에 저장해주고 이 행위를 **swap out**이라 부른다.
- 봉쇄 상태에 있는 프로세스가 0순위로 스왑 아웃 된다. → 중지봉쇄 상태로 변환
- 그래도 메모리가 부족할 경우 타이머 인터럽트가 발생해 준비큐로 이동하는 프로세스를 추가적으로 스왑아웃 시킨다. → 중지 준비 상태로 변환



# Thread

![Screen Shot 2021-03-29 at 12 31 38 AM](https://user-images.githubusercontent.com/69072471/112757780-2a6ee600-9026-11eb-8328-8fcaeba8765f.png)



- 프로세스 내부의 CPU 수행단위가 여러 개가 있는 것을 Thread라 부른다.

같은 일을 하는 프로세스를 여러개 띄어 놓는 경우 주소 공간을 하나만 만들어 놓고 각 프로세스마다 다른 코드를 실행할 수 있게 하는 것이 Thread의 기능이다.

![Screen Shot 2021-03-29 at 12 36 04 AM](https://user-images.githubusercontent.com/69072471/112757965-e4fee880-9026-11eb-9461-90341a3cd8e3.png)

![Screen Shot 2021-03-29 at 1 44 22 PM](https://user-images.githubusercontent.com/69072471/112788103-0f878a80-9095-11eb-970a-e934df9c37fa.png)

### Thread의 장점

![Screen Shot 2021-03-29 at 7 37 09 PM](https://user-images.githubusercontent.com/69072471/112825006-3611e980-90c6-11eb-83e3-b7291bd5585f.png)

**장점 1: 빠른 응답성**

*예: 웹 브라우저를 통해 네이버 페이지를 불러오려면 I/O 작업을 실행해야 하는데 이는 비교적 오래 걸리기에 웹 페이지는 block 상태가 될 수 있다. 웹 페이지를 다 불러오기전 까지 화면에는 아무것도 보이지 않을 것이기 때문에 매우 불편할 상황을 직면하게 된다.그래서 만약에 웹브라우저를 여러 개의 thread를 사용해서 만들어 놓게 되면  하나의 thread가 네이버의 이미지를 불러오는 동안 이 프로세스를 block 시키지 않고 또다른 thread가 이미 읽어온 text라도 화면에 display 해 주면 사용자는 결과를 빠르게 볼 수 있기에 답답한 부분을 해소시켜줄 수 있다.*

여러 Thread로 웹브라우저의 컨텐측를 가져오는 과정:

1. html 문서를 읽어온다
2. 그 안에 있는 이미지를 다시 웹서버에 요청을 한다.
3. 네트워크 요청을 하는 thread를 작업완료 전까지 block시킨다.
4. 이 때 다른 Thread가 이미 읽어온 text를 화면에 display 해 준다.
5. 그림은 이 후에 보여진다.

*I/O에서 비동기식 입출력을 하는 경우 위와 같은 방식으로 작동한다[디스크에서 문서를 읽어오는 경우]

**장점 2: 자원 공유**

같은 일을 하는 작업을 여러개 띄어놓게 되면 각각의 메모리 별도의 스택에 코드가 올라가야 하기 때문에 메모리가 낭비된다. 이렇게 하지 않고 하나의 프로세스에 Thread를 여러개 두고 사용하면 자원을 효율적으로 쓰는 효과를 얻을 수 있다.



**장점 3: 성능 향상**

프로세스를 하나 만드는 것은 Thread를 만드는 것 보다 오버헤드가 크다. 

Context switch를 하는 것 또한 오버헤드가 크다. 반면에 프로세스 내부에서 CPU switch가 일어나는 것은 비교적 더 간단하다. 그렇기 때문에 

따라서 동일한 일을 수행하는 다중 스레드가 협력하면 더 효율적이게 CPU를 사용할 수 있다.



**장점 4: 멀티프로세서의 병렬성에서 오는 장점**

CPU가 여러개 달린 컴퓨터에서 여러 개의 thread를 서로 다른 CPU에서 parallel하게 병렬적이게 실행할 수 있기에 결과를 비교적 더 빠르게 얻을 수 있다. 멀티프로세서 환경에서 굉장히 큰 행렬을 연산하면 더 빠른 결과를 얻을 수 있다.

![Screen Shot 2021-03-29 at 1 58 20 PM](https://user-images.githubusercontent.com/69072471/112788892-d819dd80-9096-11eb-8acb-13276ca909c1.png)

- 프로세스마다 하나의 PCB가 만들어지는데 프로세스 안에 Thread가 여러 개 있게 되면 CPU수행 관련된 독자적인 정보만 각각 Thread마다 별도의 copy를 갖게 된다(program counter, register)
- 나머지 code와 data 그리고 필요한 자료는 공유한다.

![Screen Shot 2021-03-29 at 7 35 38 PM](https://user-images.githubusercontent.com/69072471/112824826-f945f280-90c5-11eb-91ec-5f315d9b1bdd.png)



### Thread를 구현할 수 있는 방법

![Screen Shot 2021-03-29 at 7 52 18 PM](https://user-images.githubusercontent.com/69072471/112826708-4d51d680-90c8-11eb-8cef-e8a8d35d3e97.png)

- 커널 Thread
  - Thread가 여러 개 있다는 것을 운영체제가 알고 있다. 
  - 하나의 thread에서 다른 thread로 넘어가는 것을 커널이 관리한다.
- 유저 Thread
  - 프로세스 안에 thread가 여러 개 있다는 것을 운영체제가 모른다.
  - 유저 프로그램이 스스로 여러 thread를 library 지원을 받아서 관리한다.
  - 커널이 보기에는 그냥 프로세스로 보이는데 프로세스 본인 내부에서 수행단위를 만들어서 사용하기 때문에 구현적으로 제약이 존재한다.

