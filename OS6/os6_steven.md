https://www.notion.so/stevenkim18/os-6-4a3d020ea5b34772ac61be108848b7ff

# os 6강

Date: Apr 18, 2021

[반효경교수님 os 정리 잘한 블로그](https://higunnew.tistory.com/category/Operating%20System)

# 프로세스 싱크나이제이션

- 프로세스 동기화

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/_2021-04-18__3.14.01.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/_2021-04-18__3.14.01.png)

교수님께서 붙이신 이름

데이터를 저장하는 박스와 그 데이터를 가지고 연산하는 박스

## 경쟁상태(Race Condition)

- 여러 프로세스가 하나의 데이터를 접근하려고 하는 것

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled.png)

- 예를 들면 지금 `count = 10` 이라고 생각하자
- 왼쪽의 박스는 count를 1증가 시키려고 count 변수를 연산 박스로 가져갔다.
- 그런데 동시에 오른쪽 박스에서는 1을 감소하려고 count변수를 가져갔다
- 두 박스가 10을 가져간 것
- 그래서 왼쪽 박스는 1증가 시켜서 11을 저장하고
- 오른쪽 박스는 1감소 시켜 9를 저장함. 최종적으로 오른쪽 박스가 약간 늦게 했기때문에 초록박스에는 `9` 가 저장됨.
- 그런데 이는 원하는 결과가 아님 (10 → 11 → 10이 되어야 함)

### 경쟁상태가 발생하는 경우

1. 프로세스가 여러개인 경우(멀티 프로세스)
    - 여러 프로세스가 한개의 메모리에 접근하려고 할때
2. 프로세스가 공유메모리를 사용할 떄
3. 운영체제 커널과 관련된 경우
    - 프로세스가 직접 일을 할 수 없어서 시스템 콜로 커널의 프로세스에게 일을 시킬 경우

## 커널에서 실행 중인데 인터럽트가 들어왔을 때

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%201.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%201.png)

- 방금 위에 3개의 박스 그림과 같은 상황
- 다른 건 커널 프로세스와 인터럽트가 들어왔을 때라는 차이

## 커널 모드에 있는데 내가 사용할 시간이 끝나서(시분할) 다른 프로세스로 넘어갈 때

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%202.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%202.png)

- 프로세스A가 커널모드에 있는데 cpu를 사용할 시간이 다 끝나서 프로세스b로 넘어감.
- 프로세스a에서 커널모드가 건드리고 있는 변수(count)를 프로세스b에서도 건드리면..
- 이 방법에 해결책은 커널모드가 아닌 사용자 모드 일때 다른 프로세스로 넘도록 하는 방법

## 멀티 프로세스인 경우

- 수업에는 이런 경우는 잘 없음.(싱글 프로세스인 경우를 배움)

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%203.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%203.png)

- 해결 방법은 그 변수에 락을 거는 방법
- 이런 경우 보통 커널이 문제인데(커널은 컴터당 하나이기 떄문에) 커널에 락을 거는 방법

## 임계 영역

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%204.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%204.png)

- 임계영역을 만들어서 하나의 프로세스만 그 영역에 들어 올 수 있도록 한다.
- 예시에서는 `x` 를 증가 감소하는 코드를 임계영역으로 지정해 둔다.

## 동기화 문제를 해결하기 위한 3가지 충족조건

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%205.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%205.png)

- 무조건 하나의 프로세스만 임계영역에 들어가야 한다.(상호배제)
- 임계영역에 아무도 없을 때 대기하고 있는 프로세스가 들어갈 수 있어야 한다.(진행)
- 무한히 기다리면 안된다.(유한 대기 시간)

## 이를 해결하기 위한 알고리즘들

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%206.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%206.png)

```c
do {
		while(turn != 0);
		//임계영역
		turn = 1;
} while (1);
```

```c
do {
		while(turn != 1);
		//임계영역
		turn = 0;
} while (1);
```

- 왼쪽의 프로세스가 자주 들어가는 프로세스도 오른쪽은 한 두번 들어가는 것이라고 하면 왼쪽의 프로세스는 한번 들어오고 다시 들어오지 못하게 된다.

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%207.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%207.png)

- 처음에는 모든 플래그가 false로 초기화
- 정말 빠른 두 프로세스가 거의 동시에 플래그를 true로 하면 두 프로세스 다 들어가지 못하는 상황이 생길 수 있다.

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%208.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%208.png)

- 1,2번의 trun 과 플래그를 둘다 사용하는 방식
- 피터슨 알고리즘이라고도 함.
- 상호 배제, 진행, 유한 대기 시간을 모두 만족함!
- 여기에도 문제점이 있는데 while을 계속 돌면서 기다려야 하기 때문에 cpu가 낭비됨. → Busy waiting

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%209.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%209.png)

- 그래서 하드웨어적으로 지원해 줄 수 있다. atomic(원자의)

## 세마포어

- ADT 추상 자료형이다 (자료구조에 해당 되는 기능을 나열한 것)

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%2010.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%2010.png)

- P연산은 자원을 획득하는 과정
- V연산은 자원을 다시 돌려 주는 과정
- 예들 들어 자원이 3개라고 하면 3개의 프로세스가 각각 하나씩들고(P연산) 있고 다른 프로세스가 가져가려고 하면 계속 while 문을 돌면서 기다리게 된다. 한 프로세스가 자원을 다쓰고 다시 돌려놓으면(V연산) 대기 하고 있는 프로세스는 자원을 사용할 수 있게 된다.
- 이 경우에도 자원을 계속 사용하는 busy-wait 발생한다.
- 그래서 Block & Wakeup 방식으로도 구현할 수 있다.

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%2011.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%2011.png)

- 대기 하고 있는 프로세스를 블록을 시키고 대기 하고 있는 큐에 넣은 다음에 자원을 다 쓰고 나올 때 큐에 가장 먼저 있는 프로세스를 꺠워서 자원에 접근하게 하는 방식이다.
- 

![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%2012.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%2012.png)

- 그래서 P연산 내부에는 블럭을 해주는 코드를 넣고
- V연산에는 프로세스를 깨워주는 코드를 넣어서 구현이 되어 있다.

    ![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/_2021-04-18__8.36.49.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/_2021-04-18__8.36.49.png)

    ![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%2013.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%2013.png)

    - 우리가 주로 봤던 것은 세마포어가 1일 때!

    ![os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%2014.png](os%206%E1%84%80%E1%85%A1%E1%86%BC%2004d30e001df7420a960cb257fb0c3665/Untitled%2014.png)

    - 프로세스0과 1이 어떤 일을 하려면 같은 2개(S,Q)의 자원을 가져야 할 수 있다.
    - 그런데 프로세스 0은 S를 먼저 가져갔고 프로세스 1은 Q를 먼저 가져가서 서로가 일을 할 수 없게 된다. → 이런 경우 코드의 실행이 멈춘다 → 이를 데드락이라고 함.
    - 기어 현상은 식사하는 철학자문제에서 홀수의 철학자가 있을 때 한 철학자 계속 두개의 포크를 들지
